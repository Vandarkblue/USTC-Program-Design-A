# 第八次上机内容

1. 继续完成第 7 次上机试题中的全部菜单功能。

[***20-11-23***](../20-11-23/)

2. 编写一个函数，将一行字符串中最长的单词输出。此行字符串由主函数以参数形式传递给该函数，要求用指针来实现。

[**findWordLongest.c**](./findWordLongest.c)

3. 在主函数中输入一个十进制数， 编写三个函数分别将其转换成二进制、八进制和十六进制数。程序运行时先输入一个十进制数， 再输入要转换的进制（`2` 或 `8` 或 `16`），输出转换后的数字。（追加要求：能处理 `0`、负数*和浮点数*；不允许使用进制对应格式控制符；目标数字直接在函数中打印。）

[**baseConvertion.c**](./baseConvertion.c)

---

## 关于指向字符串中某字符的指针

`baseConvertion.c / main()`
```c
#define NUM 0xf

char *dest[NUM] = {NULL};
```

这是一个指针数组，其中的元素为指向某一字符型数据的指针。所有元素被初始化为 `NULL` 即 `((void *)0)` 以规避其成为野指针。野指针即未被初始化、指向未知内存区间的指针，它可能非常危险。

在本例中，它的元素指向原字符串中每一最长单词的首字母。`NUM` 为数组长度，也即最长单词数目上限。

```c
putchar(*(dest[i]+j*sizeof(char)));
```

`*(dest[i]+j*sizeof(char))` 代表第 `i+1` 个最长单词的第 `j+1` 个字母。`sizeof(char)` 是一个字符型数据的长度——在不同的编译环境当中，它的长度可能不定，当然也不一定是 `1` 字节。为了确保代码的稳定表现，这一写法是必要的。

我们或许不希望重复输出相同的最长单词，这可能会在以后的代码迭代中处理。

## 关于进制转换

`baseConvertion.c / baseConvert()` 给出了一种 `36` 以内进制整形数的进制转换方法，即除基取余法。该方法面对 “先获得的数码需要最后输出” 这一问题，代码采取递归解决；对于负数则是先转换为正数、再由正数进制转换的结果添加符号。基限制在 `36` 的原因仅仅是 `10` 个阿拉伯数字和 `26` 个西文字母可以方便地表示 `36` 以内进制数；这可以很方便地延拓。

至于浮点数，我们可以根据其在内存中的存储规律得到转换为 `2^n` 进制整数的做法。由于尾数和阶码分别存储，我们只要将其分别进行进制转换即可。这一算法涉及具体的硬件逻辑，故而在不同平台上运行的代码可能不同，在此不作展示。至于其它进制，我们并未发现通用的显式转换方法；我们欢迎于此有关的 [Pull request](https://github.com/Vandarkblue/USTC-Program-Design-A/compare)。
